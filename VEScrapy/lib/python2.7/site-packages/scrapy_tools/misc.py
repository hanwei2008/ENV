# -*- coding: utf-8 -*-
#
# misc.py
#
# Copyright (c) 2015 Chengdu Lanjing Data&Information Co., Ltd
#
import calendar
import functools
import re
import datetime

from scrapy import log


__author__ = 'Zhang Jinsong'

ugly_char_convert_dict = {u"\u00A0": u"", u"\u007F": u"", u"\u3000": u"",
                          u"\u000B": u"", u"\u000C": u"", u"\u000A": u"",
                          u"\u000D": u"", u"\u2028": u"", u"\u2029": u""}


def clean_text(unicode_text):
    """
    去除 unicode 文本中的垃圾字符，去掉相邻两汉字间的空白及 "_-" 字符
    :param unicode_text: 待处理的 unicode 文本
    :return: 净化后的 unicode 文本
    """

    text_list = list(unicode_text)
    for i, value_i in enumerate(text_list):
        if value_i in ugly_char_convert_dict.keys():
            text_list[i] = ugly_char_convert_dict[value_i]
    return re.sub(ur'(?<=[\u4e00-\u9fa5])[?*\s_-]+(?=[\u4e00-\u9fa5])', ur'', u''.join(text_list))


next_page_set = {u'下一页', u"&gt;", u"下一页»"}


def is_next_page_link(unicode_link_text):
    """
    判断某链接是否为“翻页”链接
    :param unicode_link_text: unicode 形式的链接文本
    :return: 若是“翻页”链接，返回 True，否则返回 False
    """

    clean_link_text = unicode_link_text.strip()
    return clean_link_text in next_page_set


def check_spider_pipeline(process_item_method):
    """
    装饰器，指定某 spider 只运行设定的 pipeline，需要在 spider 类中指定 pipeline 集合属性，
    然后以 @check_spider_pipeline 装饰欲参与检测的 pipeline process_item 方法。
    :param process_item_method: 待装饰的 scrapy pipeline process_item 方法。
    :return: 装饰后的方法，它会检测 process_item 所属的 spider 是否指定了该 pipeline。
    """

    @functools.wraps(process_item_method)
    def wrapper(self, item, spider):
        message = '{pipeline} pipeline '.format(pipeline=self.__class__.__name__, )
        has_set_pipeline = hasattr(spider, 'pipeline')
        if (not has_set_pipeline) \
                or (has_set_pipeline and isinstance(spider.pipeline, set) and self.__class__ in spider.pipeline):
            spider.log('{message} executing'.format(message=message), level=log.DEBUG)
            return process_item_method(self, item, spider)
        else:
            spider.log('{message} skipping'.format(message=message), level=log.DEBUG)
            return item

    return wrapper


date_complete_pattern = re.compile(
    ur'(?:^|.*?\D)((?:20|19)\d{2})\s*\D\s*(0?[1-9]|1[0-2])\s*\D\s*(0?[1-9]|[1-2][0-9]|3[0-1])(?:$|\D)')
date_complete_pattern2 = re.compile(
    ur'(?:^|.*?\D)(\d{2})\s*(\D)\s*(0?[1-9]|1[0-2])\s*(\D)\s*(0?[1-9]|[1-2][0-9]|3[0-1])(?:$|\D)')
month_day_pattern = re.compile(ur'(?:^|.*?\D)(0?[1-9]|1[0-2])\s*(\D)\s*(0?[1-9]|[1-2][0-9]|3[0-1])(?:$|\D)')
year_month_pattern = re.compile(ur'(?:^|.*?\D)((?:20|19)\d{2})\s*(\D)\s*(0?[1-9]|1[0-2])\s*(?:$|\D)')
year_pattern = re.compile(ur'(?:^|.*?\D)((?:20|19)\d{2})\s*(?:$|年)')


def _extract_date_complete_pattern(uni_date_str):
    date = None
    is_complete = False
    match = date_complete_pattern.match(uni_date_str)
    if match:
        pub_year = int(match.groups()[0])
        pub_month = int(match.groups()[1])
        pub_day = int(match.groups()[2])
        try:
            date = datetime.datetime(pub_year, pub_month, pub_day)
            is_complete = True
        except ValueError:
            pub_day = calendar.monthrange(pub_year, pub_month)[1]
            date = datetime.datetime(pub_year, pub_month, pub_day)
    return date, is_complete


def _extract_date_complete_pattern2(uni_date_str):
    date = None
    is_complete = False
    match = date_complete_pattern2.match(uni_date_str)
    if match:
        sep1 = match.groups()[1]
        sep2 = match.groups()[3]
        if (sep1 != u"月" and sep2 != u"日") and (unicode.isspace(sep1) or not unicode.isspace(sep2)):
            pub_year = int(match.groups()[0])
            pub_year = pub_year + 2000 if pub_year < 30 else pub_year + 1900
            pub_month = int(match.groups()[2])
            pub_day = int(match.groups()[4])
            try:
                date = datetime.datetime(pub_year, pub_month, pub_day)
                is_complete = True
            except ValueError:
                pub_day = calendar.monthrange(pub_year, pub_month)[1]
                date = datetime.datetime(pub_year, pub_month, pub_day)
    return date, is_complete


def _extract_month_day_pattern(uni_date_str):
    date = None
    match = month_day_pattern.match(uni_date_str)
    if match:
        seq = match.groups()[1]
        if seq != u'年' and seq != u'日':
            pub_year = datetime.datetime.today().year
            pub_month = int(match.groups()[0])
            pub_day = int(match.groups()[2])
            try:
                date = datetime.datetime(pub_year, pub_month, pub_day)
            except ValueError:
                pub_day = calendar.monthrange(pub_year, pub_month)[1]
                date = datetime.datetime(pub_year, pub_month, pub_day)
    return date, False


def _extract_year_month_pattern(uni_date_str):
    date = None
    match = year_month_pattern.match(uni_date_str)
    if match:
        seq = match.groups()[1]
        if seq != u'月' and seq != u'日':
            pub_year = int(match.groups()[0])
            pub_month = int(match.groups()[2])
            pub_day = 1
            date = datetime.datetime(pub_year, pub_month, pub_day)
    return date, False


def _extract_year_pattern(uni_date_str):
    date = None
    match = year_pattern.match(uni_date_str)
    if match:
        pub_year = int(match.groups()[0])
        pub_month = 1
        pub_day = 1
        date = datetime.datetime(pub_year, pub_month, pub_day)
    return date, False


_extract_rules = (
    _extract_date_complete_pattern,
    _extract_date_complete_pattern2,
    _extract_month_day_pattern,
    _extract_year_month_pattern,
    _extract_year_pattern,
)


def parse_date(uni_date_str):
    date = None
    is_complete = False
    for rule in _extract_rules:
        date, is_complete = rule(uni_date_str)
        if date is not None:
            break
    return date, is_complete
